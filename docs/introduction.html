<!-- introduction -->
<html>
  <!DOCTYPE HTML PUBLIC
   "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

  <head>
    <title>
      introduction
    </title>
    <meta http-equiv="Content-Type"
          content="text/html"
          charset="UTF-8" />
    <link rel="stylesheet" href="helambdap.css" />
  </head>
  <body>
    <h1>
      cl-gserver
      introduction
    </h1>
    <p>
      <h2 id="org1dda1dc"><span class="section-number-2">0</span> Before Intro</h2>
      <div class="outline-text-2" id="text-1">
        <p>
          Make sure to check the 'Dictionary' link on the top for the API documentation!
        </p>
      </div>
<div id="outline-container-org35612df" class="outline-2">
<h2 id="org35612df"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
cl-gserver is a 'message passing' library/framework with actors similar to Erlang or Akka.
</p>

<p>
<b>Version 1.3.1 adds: round-robin strategy for router</b>
</p>

<p>
<b>Version 1.3 adds: agents can be created in actor-system</b>
</p>

<p>
<b>Version 1.2 introduces a breaking change</b>
</p>

<p>
<code>ask</code> has been renamed to <code>ask-s</code>.
</p>

<p>
<code>async-ask</code> has been renamed to <code>ask</code>.
</p>

<p>
The proposed default way to query for a result from another actor should be an asynchronous <code>ask</code>. <code>ask-s</code> (synchronous) is of course still possible. 
</p>

<p>
<b>Version 1.0</b> of <code>cl-gserver</code> library comes with quite a few new features. One of the major new features is that an actor is not bound to it's own message dispatcher thread. Instead, when an <code>actor-system</code> is set-up, actors can use a shared pool of message dispatchers which effectively allows to create millions of actors.
</p>

<p>
It is now possible to create actor hierarchies. An actor can have child actors. An actor now can also 'watch' another actor to get notified about it's termination.
</p>

<p>
It is also possible to specify timeouts for the <code>ask-s</code> and <code>ask</code> functionality.
</p>

<p>
This new version is closer to Akka (the actor model framework on the JVM) than to GenServer on Erlang. This is because Common Lisp from a runtime perspective is closer to JVM than to Erlang/OTP. Threads in Common Lisp are heavy weight OS threads rather than user-space low weight 'Erlang' threads (I'd like to avoid 'green threads', because threads in Erlang are not really green threads). While on Erlang it is easily possible to spawn millions of processes/threads and so each actor (GenServer) has its own process, this model is not possible when the threads are OS threads, because of OS resource limits.
This is the main reason for working with the message dispatcher pool instead.
</p>

<p>
But let's jump right into it. I'll explain more later.
</p>
</div>
</div>

<div id="outline-container-orgc3be503" class="outline-2">
<h2 id="orgc3be503"><span class="section-number-2">2</span> Getting hands-on</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org87dc7ac" class="outline-3">
<h3 id="org87dc7ac"><span class="section-number-3">2.1</span> Creating an actor-system</h3>
<div class="outline-text-3" id="text-2-1">
<p>
To use the shared dispatcher pool we have to create an <code>actor-system</code> first.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvar *system* (asys:make-actor-system))
</pre>
</div>

<p>
When we eval <code>*system*</code> in the repl we see a bit of the structure:
</p>

<pre class="example">
#&lt;ACTOR-SYSTEM shared-workers: 4, user actors: 0, internal actors: 0&gt;
</pre>

<p>
So the <code>actor-system</code> has by default four shared message dispatcher workers. Depending on how busy the system tends to be this default can of course be increased.
</p>
</div>

<div id="outline-container-org6ade691" class="outline-4">
<h4 id="org6ade691"><span class="section-number-4">2.1.1</span> Shutting down the system</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Shutting down an actor system may be necessary depending on how it's used. It can be done by:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ac:shutdown *system*)
</pre>
</div>

<p>
This will stop all dispatcher workers and all other actors that have been spawed in the system.
</p>
</div>
</div>
</div>

<div id="outline-container-orgda3e2a7" class="outline-3">
<h3 id="orgda3e2a7"><span class="section-number-3">2.2</span> Creating actors</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Actors kind of live within an <code>actor-context</code>. An <code>actor-context</code> contains a collection (of actors) and defines a Common Lisp protocol that spawns a set of generic functions.
</p>

<p>
There are two 'things' that host an <code>actor-context</code>. This is: 
</p>
<ol class="org-ol">
<li>the <code>actor-system</code>. Creating actors on the <code>actor-system</code> will create root actors.</li>
<li>the <code>actor</code>. Creating actors on the context of an actor will create a child actor.</li>
</ol>

<p>
Here we now use the <code>actor-context</code> protocol/api nicknamed <code>ac</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ac:actor-of *system* (lambda ()
                        (act:make-actor 
                             (lambda (self msg state)
                               (let ((output (format nil "Hello ~a" msg)))
                                 (format t "~a~%" output)
                                 (cons output state)))
                             :name "answerer")))
</pre>
</div>

<p>
This creates a root actor on the <code>*system*</code>. Notice that the actor is not assigned to a variable. It is now registered in the system. The main argument to the <code>actor-of</code> function is a 'creator-function' which when evaluated returns an actor created with the main actor constructor <code>make-actor</code>.
</p>

<p>
<code>make-actor</code> requires as main parameter a 'behavior' function which should look familiar if you know the previous version of cl-gserver. The parameters to the 'behavior' function are still the tuple of:
</p>
<ol class="org-ol">
<li><code>self</code> - the instance of the actor</li>
<li><code>msg</code> - the received message of when this 'behavior function is called</li>
<li><code>state</code> - the current state of the actor</li>
</ol>

<p>
The return value of the 'behavior' function should also be familiar. It is the <code>cons</code> with <code>car</code> being sent back to sender (in case of ask/ask) and <code>cdr</code> set as the new state of the actor.
</p>

<p>
The function <code>actor-of</code> still returns the actor as can be seen on the repl when this is executed. So it is of course possible to store the actor in a dynamic or lexical context. However, when the lexical context ends, the actor will still live as part of the actor context.
</p>

<p>
Here we see a few details of the actor. Among which is the name and also the type of message-box it uses. By default it is a <code>message-box/dp</code> which is the type of a shared message dispatcher message-box.
</p>

<pre class="example">
#&lt;ACTOR answerer, running: T, state: NIL, message-box: #&lt;MESSAGE-BOX/DP mesgb-9541, processed messages: 0, max-queue-size: 0, queue: #&lt;QUEUE-UNBOUNDED #x3020029918FD&gt;&gt;&gt;
</pre>

<p>
Had we stored the actor to a variable, say <code>*answerer*</code> we can create a child actor of that by doing:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ac:actor-of (act:context *answerer*) 
                          (lambda ()
                            (act:make-actor
                             (lambda (self msg state)
                               (let ((output (format nil "~a" "Hello-child ~a" msg)))
                                 (format t "~a~%" output)
                               (cons output state)))
                             :name "child-answerer")))
</pre>
</div>

<p>
This will create a new actor on the context of the parent actor. The context is retrieved with <code>(act:context *answerer*)</code>.
</p>
</div>

<div id="outline-container-org1a450ce" class="outline-4">
<h4 id="org1a450ce"><span class="section-number-4">2.2.1</span> <code>:pinned</code> vs. <code>:shared</code></h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
By default an actor, created using <code>actor-of</code>, uses a <code>:shared</code> dispatcher type which uses the shared message dispatchers that are setup in the system. It is also possible to create actors with their own dispatcher thread, those are called <code>:pinned</code> actors. Just provide the <code>:pinned</code> value to the <code>dispatcher-type</code> key parameter.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbce9a5a" class="outline-3">
<h3 id="orgbce9a5a"><span class="section-number-3">2.3</span> Finding actors in the context</h3>
<div class="outline-text-3" id="text-2-3">
<p>
If actors are not directly stored in a dynamic or lexical context they can still be looked up and used. The <code>actor-context</code> protocol contains a function <code>find-actors</code> which works like this:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(first (ac:find-actors 
                 *system*
                 (lambda (actor) (string= "answerer" 
                                          (act-cell:name actor)))))
</pre>
</div>

<p>
<code>find-actors</code> takes as first parameter the actor context. This can be either the actor system, or the context of an actor. The second parameter is a test function. This example makes a string comparison on the actor name. So the above function will output:
</p>

<pre class="example">
#&lt;ACTOR answerer, running: T, state: NIL, message-box: #&lt;MESSAGE-BOX/DP mesgb-9687, processed messages: 0, max-queue-size: 0, queue: #&lt;QUEUE-UNBOUNDED #x30200263C95D&gt;&gt;&gt;
</pre>

<p>
This function only does a simple flat search. The functionality of looking up an actor in the system generally will be expanded upon.
</p>
</div>
</div>

<div id="outline-container-org6b65d83" class="outline-3">
<h3 id="org6b65d83"><span class="section-number-3">2.4</span> tell, ask-s and ask</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Let's send some messages.
</p>
</div>

<div id="outline-container-org95442da" class="outline-4">
<h4 id="org95442da"><span class="section-number-4">2.4.1</span> tell</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
<code>tell</code> is a fire-and-forget kind of send type. It doesn't expect a result in return.
</p>

<p>
And because of that, and in order to demonstrate it does something, it has to have a side-effect. So it dumps some string to the console using <code>format</code>, because we couldn't otherwise <code>tell</code> if the message was received and processed (see the <code>*answerer*</code> actor definitions above).
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (act:tell *answerer* "Foo")
T
CL-USER&gt; 
Hello Foo
</pre>
</div>

<p>
So we see that <code>tell</code> returns immediately with <code>T</code>. But to see the 'Hello Foo' it takes another hit on the return key, because the REPL is not asynchronous.
</p>
</div>
</div>

<div id="outline-container-orgf4a0a2a" class="outline-4">
<h4 id="orgf4a0a2a"><span class="section-number-4">2.4.2</span> tell with sender</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
<code>tell</code> accepts a 'sender', which has to be an actor. So we can do like this:
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (act:tell *child-answerer* "Foo" *answerer*)
T
CL-USER&gt; 
Hello-child Foo
Hello Hello-child Foo
</pre>
</div>

<p>
This sends "Foo" to <code>*child-answerer*</code>, but <code>*child-answerer*</code> sends the response to <code>*answerer*</code>. So we see outputs of both actors.
</p>
</div>
</div>

<div id="outline-container-org6989275" class="outline-4">
<h4 id="org6989275"><span class="section-number-4">2.4.3</span> ask-s</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
<code>ask-s</code> blocks until the message was processed by the actor. This call returns the <code>car</code> part of the <code>cons</code> return of the behavior function.
Insofar an <code>ask-s</code> call is more resource intensive than just a <code>tell</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(act:ask-s *answerer* "Bar")
</pre>
</div>

<p>
Will respond with: 'Hello Bar'
</p>
</div>
</div>

<div id="outline-container-org7c7c3c0" class="outline-4">
<h4 id="org7c7c3c0"><span class="section-number-4">2.4.4</span> ask</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
<code>ask</code> combines both <code>ask-s</code> and <code>tell</code>. From <code>ask-s</code> it 'inherits' returning a result, even though it's a future result.
Internally it is implemented using <code>tell</code>. In order to wait for a result a temporary actor is spawned that waits until it receives the result from the actor where the message was sent to. With this received result the future is fulfilled.
So <code>ask</code> is async, it returns immediately with a <code>future</code>. That <code>future</code> can be queried until it is fulfilled. Better is though to setup an <code>on-completed</code> handler function on it.
</p>

<p>
So we can do:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(future:on-completed
          (act:ask *answerer* "Buzz")
          (lambda (result)
            (format t "Received result: ~a~%" result)))
</pre>
</div>

<p>
Well, one step at a time:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(act:ask *answerer* "Buzz")
</pre>
</div>

<p>
Returns with:
</p>

<pre class="example">
#&lt;FUTURE promise: #&lt;PROMISE finished: NIL errored: NIL forward: NIL #x302002EAD6FD&gt;&gt;
</pre>

<p>
Then we can setup a completion handler on the future:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(future:on-completed 
          *
          (lambda (result)
            (format t "Received result: ~a~%" result)))
</pre>
</div>

<p>
Remember '*' is the last result in the REPL which is the future here.
</p>

<p>
This will print after a bit:
</p>

<pre class="example">
Hello Buzz
Received result: Hello Buzz
</pre>
</div>
</div>
</div>

<div id="outline-container-org3107f92" class="outline-3">
<h3 id="org3107f92"><span class="section-number-3">2.5</span> ask-s and ask with timeout</h3>
<div class="outline-text-3" id="text-2-5">
<p>
A timeout (in seconds) can be specified for both <code>ask-s</code> and <code>ask</code> and is done like so:
</p>

<p>
To demonstrate this we could setup an example 'sleeper' actor:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ac:actor-of *system* 
             (lambda () (act:make-actor 
                           (lambda (self msg state)
                             (sleep 5)))))
</pre>
</div>

<p>
If we store this to <code>*sleeper*</code> and do the following, the <code>ask-s</code> will return a <code>handler-error</code> with an <code>ask-timeout</code> condition.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(act:ask-s *sleeper* "Foo" :time-out 2)
</pre>
</div>

<pre class="example">
(:HANDLER-ERROR . #&lt;CL-GSERVER.UTILS:ASK-TIMEOUT #x30200319F97D&gt;)
</pre>

<p>
This works similar with the <code>ask</code> only that the future will be fulfilled with the <code>handler-error</code> <code>cons</code>.
</p>

<p>
To get a readable error message of the condition we can do:
</p>

<pre class="example">
CL-USER&gt; (format t "~a" (cdr *))
A timeout set to 2 seconds occurred. Cause: 
#&lt;BORDEAUX-THREADS:TIMEOUT #x302002FAB73D&gt; 
</pre>
</div>
</div>

<div id="outline-container-org105f3bc" class="outline-3">
<h3 id="org105f3bc"><span class="section-number-3">2.6</span> Long running operations in <code>receive</code></h3>
<div class="outline-text-3" id="text-2-6">
<p>
Be careful with doing long running computations in the <code>receive</code> function message handler, because it will block message processing.
It is advised to use a third-party thread-pool or a library like <i>lparallel</i> to do the computations with and return early from the <code>receive</code> message handler.
</p>

<p>
Considering the required <code>cons</code> return result of the <code>receive</code> function, in case a result computation is delegated to a thread-pool the <code>receive</code> function should return with <code>(cons :no-reply &lt;state&gt;)</code>. The <code>:no-reply</code> will instruct the actor to <i>not</i> send a result to a sender automatically should a sender be available (for the cases of <code>tell</code> or <code>ask</code>). The computation result can be 'awaited' for in an asynchronous manner and a response to <code>*sender*</code> can be sent manually by just doing a <code>(tell *sender* &lt;my-computation-result&gt;)</code>. The sender of the original message is set to the dynamic variable <code>*sender*</code>. 
</p>

<p>
Due to an asynchronous callback of a computation running is a separate thread, the <code>*sender*</code> must be copied into a lexical environment because at the time of when the callback is executed the <code>*sender*</code> can have a different value.
</p>

<p>
This behavior must be part of the messaging protocol that is being defined for the actors at play.
</p>
</div>
</div>

<div id="outline-container-org8828b64" class="outline-3">
<h3 id="org8828b64"><span class="section-number-3">2.7</span> Changing behavior</h3>
<div class="outline-text-3" id="text-2-7">
<p>
An actor can change behavior. The behavior is just a lambda that has to take three parameters: 
</p>
<ol class="org-ol">
<li>the actor's instance - usually called <code>self</code></li>
<li>the received message - maybe call <code>msg</code>?</li>
<li>the current state of the actor</li>
</ol>

<p>
The behavior then can pattern match (or do some matching by other means) on the received message alone, or in combination with the current state.
</p>

<p>
The default behavior of the actor is given on actor construction using the default constructor <code>make-actor</code>.
</p>

<p>
During the lifetime of an actor the behavior can be changed using <code>become</code>.
</p>

<p>
So we remember the <code>*answerer*</code> which responds with 'Hello Foo' when we send <code>(act:ask-s *answerer* "Foo")</code>. We can now change the behavior with:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(act:become *answerer* 
            (lambda (self msg state)
              (cons (format nil "my new behavior for: ~a" msg) state)))
</pre>
</div>

<p>
When we now send <code>(act:ask-s *answerer* "Foo")</code> we will get the response: 'my new behavior for: Foo'.
</p>

<p>
<b>Reverting <code>become</code> / <code>unbecome</code></b>
</p>

<p>
To revert back to the default behavior as defined by the <code>receive</code> function of the constructor you may call <code>unbecome</code>.
</p>
</div>
</div>

<div id="outline-container-org8165a1d" class="outline-3">
<h3 id="org8165a1d"><span class="section-number-3">2.8</span> Creating actors without a system</h3>
<div class="outline-text-3" id="text-2-8">
<p>
It is still possible to create actors without a system. This is how you do it:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; make an actor
(defvar *my-actor* (act:make-actor (lambda (self msg state)
                                     (cons "Foo" state))
                                   :name "Lone-actor"))
;; setup a thread based message box
(setf (act-cell:msgbox *my-actor*) 
      (make-instance 'mesgb:message-box/bt))
</pre>
</div>

<p>
You have to take care yourself about stopping the actor and freeing resources.
</p>
</div>
</div>
</div>

<div id="outline-container-org1878c49" class="outline-2">
<h2 id="org1878c49"><span class="section-number-2">3</span> Agents</h2>
<div class="outline-text-2" id="text-3">
<p>
An Agent is a specialized Actor. It is meant primarily for maintaining state and comes with some conveniences to do that.
</p>

<p>
To use an Agent import <code>cl-gserver.agent</code> package.
</p>

<p>
There is no need to subclass an Agent. Rather create a facade to customermize an agent. See below.
</p>

<p>
An Agent provides three functions to use it.
</p>

<ul class="org-ul">
<li><code>make-agent</code> creates a new agent</li>
<li><code>agent-get</code> retrieves the current state of the agent. This directly delivers the state of the agent for performance reasons. There is no message handling involved.</li>
<li><code>agent-update</code> updates the state of the agent</li>
</ul>

<p>
All three take a lambda.  
The lambda for <code>make-agent</code> does not take a parameter. It should return the initial state of the agent.  
<code>agent-get</code> and <code>agent-update</code> both take a lambda that must support one parameter. This parameter represents the current state of the agent.
</p>

<p>
Let's make a simple example:
</p>

<p>
First create an agent with an initial state of <code>0</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defparameter *my-agent* (make-agent (lambda () 0)))
</pre>
</div>

<p>
Now update the state several times (<code>agent-update</code> is asynchronous and returns <code>t</code> immediately):
</p>

<div class="org-src-container">
<pre class="src src-lisp">(agent-update *my-agent* (lambda (state) (1+ state)))
</pre>
</div>

<p>
Finally get the state:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(agent-get *my-agent* #'identity)
</pre>
</div>

<p>
This <code>agent-get</code> just uses the <code>identity</code> function to return the state as is.
</p>

<p>
So this simple agent represents a counter.
</p>

<p>
It is important to note that the retrieves state, i.e. with <code>identity</code> should not be modified outside the agent.
</p>
</div>

<div id="outline-container-org34660c3" class="outline-3">
<h3 id="org34660c3"><span class="section-number-3">3.1</span> Using an agent within an actor-system</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The <code>make-agent</code> constructor function allows to provides an optional <code>system</code> argument that, when given, makes the constructor create the agent within the given actor-system. This implies that the systems shared messages dispatcher is used for the agent and no separate thread is created for the agents message box.
</p>

<p>
It also implies that the agent is destroyed then the actor-system is destroyed.
</p>

<p>
However, while actors can create hierarchies, agents can not. Also the API for creating agents in systems is different to actors. This is to make explicit that agents are treated slightly differently than actors even though under the hood agents are actors.
</p>
</div>
</div>

<div id="outline-container-org6eee9a4" class="outline-3">
<h3 id="org6eee9a4"><span class="section-number-3">3.2</span> Wrapping an agent</h3>
<div class="outline-text-3" id="text-3-2">
<p>
While you can use the agent as in the example above it is usually advised to wrap an agent behind a more simple facade that doesn't work with lambdas.
</p>

<p>
For example could a facade for the counter above look like this:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvar *counter-agent* nil)

(defun init-agent (initial-value)
  (setf *counter-agent* (make-agent (lambda () initial-value))))

(defun increment () (agent-update *counter-agent* #'1+))
(defun decrement () (agent-update *counter-agent* #'1-))
(defun counter-value () (agent-get *counter-agent* #'identity))
</pre>
</div>

<p>
Alternatively, one can wrap an agent inside a class and provide methods for simplified access to it.
</p>
</div>
</div>
</div>

<div id="outline-container-org5a2b582" class="outline-2">
<h2 id="org5a2b582"><span class="section-number-2">4</span> Router</h2>
<div class="outline-text-2" id="text-4">
<p>
A <code>Router</code> is a facade over a set of actors. Routers are either created with a set of actors using the default constructor <code>router:make-router</code> or actors can be added later.
</p>

<p>
Routers implement part of the actor protocol, so it allows to use <code>tell</code>, <code>ask-s</code> or <code>ask</code> which it forwards to a 'routee' (one of the actors of a router) by passing all of the given parameters. The routee is chosen by applying a <code>strategy</code>. The built-in default strategy a routee is chosen randomly.
</p>

<p>
The <code>strategy</code> can be configured when creating a router using the constructors <code>&amp;key</code> parameter <code>:strategy</code>. The <code>strategy</code> is just a function that takes the number of routees and returns a routee index to be chosen for the next operation.
</p>

<p>
Currently available strategies: <code>:random</code> and <code>:round-robin</code>.
</p>

<p>
Custom strategies can be implemented.
</p>
</div>
</div>

    </body>
</html>
<!-- end of file :  introduction -->
